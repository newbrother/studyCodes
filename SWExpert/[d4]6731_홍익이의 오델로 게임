//밑의 주석의 방법이 틀렸나보다...케이스 빼고 n^2승에 예외처리 까지했는데 시간초과가 나서 실패 


//타겟행렬의 가로,세로의 B(1)의 개수를 더한값이 홀수인것의 개수를 구하면 된다.

#include <stdio.h>
char input[1001][1001];
int arr2[1001][1001];

int main() {
    int t;
    scanf("%d", &t);
    for (int caseCnt = 1; caseCnt <= t; caseCnt++) {
        int n;
        int cnt = 0;
        scanf("%d", &n);
        int i, j;
        int x = 0, y = 0;
        int bCnt = 0;

        for (i = 0; i < n; i++) {
            scanf("%s", input[i]);
        }
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (input[i][j] == 'B') {
                    arr2[i][j] = -1;
                    x++;
                }
                else {
                    arr2[i][j] = 0;
                }
            }
            for (j = 0; j < n; j++) {
                arr2[i][j] += x;
            }
            bCnt += x;
            x=0;
        }
        if (bCnt == n*n) {
            printf("#%d %d\n", caseCnt, bCnt);
            continue;
        }

        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (input[j][i] == 'B')
                    y++;
            }
            for (j = 0; j < n; j++) {
                arr2[j][i] += y;
                if (arr2[j][i] % 2 == 1) {
                    cnt++;
                }
            }
            y = 0;
        }
        
        printf("#%d %d\n", caseCnt, cnt);
    }

}
